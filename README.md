# GIS-Drone
This drone is designed to fly and survey, collect images with GPS locations and convert them into maps that can be viewed on the web.

## Structure
<img src="https://github.com/ShoIsMyName/GIS-Drone/blob/main/GisDroneBodyFirstLayer.png?raw=true" style="width: 80%">
<img src="https://github.com/ShoIsMyName/GIS-Drone/blob/main/GisDroneBodySecondLayer.png?raw=true" style="width: 80%">

## Image-Stitcher ðŸ“·
>All captured images will be saved in one of the directories (can be selected by editing the settings in the source code). The images will then be imported and stitched together into a map using the cv2 library with the Stitcher function.
``` python
import cv2
import os
from colorama import Fore


################################################
#####                                      #####
#####          SETTING ALL HERE            #####
#####                                      #####
################################################

folderPath = "./ImageFolder"
resultFolderPath = "./ResultMapFolder"
verbose = True



try:
    contents = os.listdir(folderPath)
except:
    if verbose:
        print(f"[{Fore.RED}X{Fore.RESET}] No directory name \"{folderPath}\".")
    os._exit(1)

imageList = []

try:
    # append images (not filenames) to imageList
    for item in contents:
        full_path = os.path.join(folderPath, item)
        if os.path.isfile(full_path):
            img = cv2.imread(full_path)
            if img is not None:
                imageList.append(img)
except:
    if verbose:
        print(f"[{Fore.RED}X{Fore.RESET}] Can't import any file from \"{folderPath}\" directory.")
    os._exit(1)

try:
    # stitcher the picture into map
    stitcher = cv2.Stitcher_create()
    status, resultMap = stitcher.stitch(imageList)
except:
    if verbose:
        print(f"[{Fore.RED}X{Fore.RESET}] Error to stitcher.")
    os._exit(1)

# [FUNCTION] Check length file in directory
def count_files_in_directory(directory_path):
    count = 0
    for item in os.listdir(directory_path):
        item_path = os.path.join(directory_path, item)
        if os.path.isfile(item_path):
            count += 1
    return count

sequenceFileInDirectoryNumber = count_files_in_directory(resultFolderPath)

if status == cv2.Stitcher_OK:
    if verbose:
        cv2.imwrite(f"./ResultMapFolder/resultMap{sequenceFileInDirectoryNumber+1}.jpg", resultMap)
    print(f"[{Fore.GREEN}#{Fore.RESET}] Stitching complete!")
else:
    if verbose:
        print(f"[{Fore.RED}X{Fore.RESET}] Stitching failed: ", status)
```


# Remote by "Remotexy" ðŸŽ®
This is a drone controller using a bluetooth module.


## manual
1. Download the source code for board, open it in the Arduino IDE.

2. Install the RemoteXY library for Arduino IDE.

3. Compile the source code and upload it to the board using the Arduino IDE.

4. Correctly connect HC-05(06) Bluetooth module to the board.

5. Install the mobile app RemoteXY to your phone or tablet.

6. Connect to board using mobile app.


## Controller
<img src="https://github.com/ShoIsMyName/RemotexyDroneGis/blob/main/Controller.png?raw=true" style="width: 80%">

## Source code
``` c++
/*
   -- New project --
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             
*/

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG    

// RemoteXY select connection mode and include library 
#define REMOTEXY_MODE__SOFTSERIAL

#include <SoftwareSerial.h>

// RemoteXY connection settings 
#define REMOTEXY_SERIAL_RX 2
#define REMOTEXY_SERIAL_TX 3
#define REMOTEXY_SERIAL_SPEED 9600


#include <RemoteXY.h>

// RemoteXY GUI configuration  
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 48 bytes
  { 255,4,0,0,0,41,0,19,0,0,0,0,8,2,106,200,200,84,1,1,
  2,0,5,207,12,143,143,19,25,52,52,0,8,16,31,5,219,64,124,124,
  129,26,52,52,0,8,16,31 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  int8_t joystick_01_x; // from -100 to 100
  int8_t joystick_01_y; // from -100 to 100
  int8_t joystick_02_x; // from -100 to 100
  int8_t joystick_02_y; // from -100 to 100

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   
#pragma pack(pop)
 
/////////////////////////////////////////////
//           END RemoteXY include          //
/////////////////////////////////////////////



void setup() 
{
  RemoteXY_Init (); 
  
  
  // TODO you setup code
  
}

void loop() 
{ 
  RemoteXY_Handler ();
  
  
  // TODO you loop code
  // use the RemoteXY structure for data transfer
  // do not call delay(), use instead RemoteXY_delay() 


}
```
